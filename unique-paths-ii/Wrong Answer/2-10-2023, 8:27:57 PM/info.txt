{"id":895313675,"lang":"java","lang_name":"Java","time":"2 months, 1 week","timestamp":1676032077,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/895313675/","is_pending":"Not Pending","title":"Unique Paths II","memory":"N/A","code":"// import java.util.List;\n// import java.util.Scanner;\n// import java.util.ArrayList;\n\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] == 1 || obstacleGrid[0][0] == 1) {\n            return 0;\n        }\n        boolean hasObstacles = false;\n        for (int i = 0; i < obstacleGrid.length; i++) {\n            for (int j = 0; j < obstacleGrid[0].length; j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    hasObstacles = true;\n                }\n            }\n        }\n        if (hasObstacles) {\n            int min = Math.min(obstacleGrid.length, obstacleGrid[0].length);\n            \n            for(int a = 0; a < min; a ++){\n                for(int b = 1 ; b <= a; b++){\n                    int temp = 1;\n                    for(int c = 1 ; c <= a; c++){\n                        if(b == a || c == a){\n                            temp = temp * obstacleGrid[b][c];\n                        }\n                    }\n                    if(temp == 1){\n                        System.out.println(\"blocked\");\n                        return 0;\n                    }\n                }\n            }\n            for (int i = 0; i < obstacleGrid.length; i++) { // 檢驗如果整列都是1那就直接return 0\n                int temp = 1;\n                for (int j = 0; j < obstacleGrid[0].length; j++) {\n                    temp = temp * obstacleGrid[i][j];\n                }\n                if (temp == 1) {\n                    System.out.println(\"whole line\");\n                    return 0;\n                }\n            }\n\n            for (int i = 0; i < obstacleGrid.length; i++) { // 邊邊有障礙物 = 0, 沒有的話default 1\n                if (obstacleGrid[i][0] == 1) {\n                    obstacleGrid[i][0] = 0;\n                } else {\n                    obstacleGrid[i][0] = 1;\n                }\n            }\n            for (int i = 0; i < obstacleGrid[0].length; i++) { // 邊邊有障礙物 = 0, 沒有的話default 1\n                if (obstacleGrid[0][i] == 1) {\n                    obstacleGrid[0][i] = 0;\n                } else {\n                    obstacleGrid[0][i] = 1;\n                }\n            }\n            for (int i = 1; i < obstacleGrid.length; i++) {\n                for (int j = 1; j < obstacleGrid[0].length; j++) {\n                    if (obstacleGrid[i][j] != 1) {// 如果不是障礙物就執行相加\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n                    } else {\n                        obstacleGrid[i][j] = 0;\n                    }\n                }\n            }\n            System.out.println(\"normal\");\n            return obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1];\n        } else {\n            int l = obstacleGrid.length - 1;\n            int m = obstacleGrid[0].length - 1;\n            // (l+m)!/l!m!\n            int temp = 1;\n            for (int i = l + m; i > l; i--) {\n                temp = temp * i;\n            }\n            for (int i = 1; i <= m; i++) {\n                temp = temp / i;\n            }\n            System.out.print(\"no obstacle\");\n            return temp;\n        }\n    }\n}","compare_result":"01111111111111111110010110100000000010011","title_slug":"unique-paths-ii","has_notes":false}